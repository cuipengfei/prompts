---
name: auto-extract
description: 会话学习技能 - 双模式学习引擎：会话范围分析当前会话，历史范围批量分析日志发现配置改进点
---

# 会话学习技能

双模式学习引擎：分析交互内容，提取有价值的学习并持久化。

## 模式路由

本技能有两种工作模式。**先判断模式，再执行对应流程。**

判断规则（按优先级）：

1. **参数以 "历史分析" 开头** → **历史模式**（跳转到末尾的"历史分析模式"section）
2. **其他情况** → **会话模式**（执行下方"分析维度"开始的现有流程）

注意：参数中偶然包含"历史"一词（如"分析历史片段"）**不触发**历史模式。只有参数以"历史分析"作为显式前缀时才切换。

---

## 会话模式（默认）

以下为会话模式的完整流程。

## 分析维度

回顾会话，关注：

| 维度 | 关注点 |
|------|--------|
| **进展顺利** | 成功的方法、有效的解决方案、好的决策 |
| **进展不顺** | 失败的尝试、错误的方向、浪费时间的地方 |
| **用户分歧** | 用户纠正你的地方、拒绝的建议、表达不满的地方 |
| **推断偏好** | 沟通风格、工具偏好、代码风格、工作流习惯 |

## 四层分类

### 语义定义

| 层级 | 核心问题 | 特性 |
|------|----------|------|
| Layer 1: 用户配置 | "每个会话都需要知道什么？" | 跨项目、身份性、自动加载 |
| Layer 2: 项目根配置 | "这个项目整体需要知道什么？" | 项目级、版本控制 |
| Layer 3: 子模块配置 | "这个子模块需要知道什么？" | 子模块特定、就近原则 |
| Layer 4: 情境记忆 | "特定情境下需要召回什么？" | 情境性、按需查询 |

### 硬规则：单条知识唯一归属

- 每条学习项选择一个且仅一个存储层。
- 禁止跨层重复（包括改写后的同义重复）。
- 写入前，执行跨层去重检查：在所有已探测到的存储位置检索关键词。
- 发现重复或冲突时，使用 AskUserQuestion 让用户决定（移动 / 覆盖 / 忽略）；默认不自动覆盖。

### 决策树

```
对于每个学习项，依次问：
│
├─ Q1: 是否是每个新会话、跨所有项目都需要的信息？
│   ├─ 是 → Layer 1 用户配置
│   └─ 否 → 继续 Q2
│
├─ Q2: 是否与当前项目整体相关？
│   ├─ 是 → Layer 2 项目根配置
│   └─ 否 → 继续 Q3
│
├─ Q3: 是否与项目中某个特定子模块/子目录相关？
│   ├─ 是 → Layer 3 子模块配置（写入最近的子目录配置文件）
│   └─ 否 → 继续 Q4
│
└─ Q4: 是否是特定情境才需要的经验/知识/解决方案？
    └─ 是 → Layer 4 情境记忆
```

**关键区分**：
- **用户配置**: "What I always need to know"（身份/常驻规则）
- **项目根配置**: "What this project needs to know"（项目约定）
- **子模块配置**: "What this submodule needs to know"（子模块约定，就近放置）
- **情境记忆**: "What I learned for specific situations"（情境经验）

### 分类示例

| 学习内容 | 层级 | 理由 |
|----------|------|------|
| "用户偏好 bun 而非 npm" | L1 用户 | 跨项目的工具选择 |
| "用户偏好简洁响应" | L1 用户 | 跨项目的风格偏好 |
| "用户偏好中文交流" | L1 用户 | 跨项目的语言设置 |
| "这个项目有 19 个独立插件" | L2 项目根 | 项目整体结构 |
| "插件 plugin.json 不要用 $schema 字段" | L2 项目根 | 项目通用规范 |
| "oc-tweaks 发布必须走 CI，禁止 npm publish" | L3 子模块 | oc-tweaks 子模块特定 |
| "openspec proposal 必须包含 Why 和 What Changes" | L3 子模块 | openspec 子模块特定 |
| "GitHub Code Search 按相关性排序" | L4 情境记忆 | 特定技术的经验教训 |
| "并行 API 调用用 ThreadPoolExecutor" | L4 情境记忆 | 特定场景的解决方案 |

## 存储层探测协议

在持久化前，先探测当前环境可用的存储后端。**不假设任何特定插件或 MCP 存在。**

### 第零步：探测可用后端

#### Layer 1 — 用户配置

扫描用户级配置文件，检测是否存在：
- `~/.claude/CLAUDE.md`
- 其他用户级 agent 配置文件

检测到的文件均参与去重检查。不存在则创建 `~/.claude/CLAUDE.md` 并添加适当头部。

#### Layer 2 — 项目根配置

扫描项目根目录，检测以下文件是否存在：
- `{repo}/AGENTS.md`
- `{repo}/CLAUDE.md`
- `{repo}/.claude/CLAUDE.md`

所有检测到的文件均参与去重检查。写入时选择语义最合适的一个。

#### Layer 3 — 子模块配置

扫描项目中子目录里已存在的配置文件（AGENTS.md 或 CLAUDE.md）。这些文件代表该子模块有独立的知识边界。

**探测方式**: 搜索 `{repo}/**/AGENTS.md` 和 `{repo}/**/CLAUDE.md`（排除根目录，排除 node_modules 等）。

所有检测到的文件均参与去重检查。写入时选择与学习内容语义最近的子模块配置。如果没有发现任何子模块配置文件，则将 Q3 的内容归入 Layer 2。

#### Layer 4 — 情境记忆

按优先级探测可用的记忆后端：

1. **记忆相关的工具**: 检查当前环境是否有可调用的记忆存储工具（能创建、查询、更新知识条目的工具）。有则用。
2. **已存在的 memory 目录**: 检查项目级或全局是否存在 memory 目录（含 `*.md` 文件）。有则用 Read/Edit/Write 操作。
3. **兜底**: 以上都不可用 → 在项目内创建 `.memory/` 目录，以 markdown 文件存储。

**原则**: 探测到什么用什么。不要求用户安装任何额外依赖。

## 持久化指南

### Layer 1：用户配置

**写入目标**: 探测到的用户级配置文件

**插入策略**:
1. **先阅读整个文件**，理解现有结构
2. **找到语义合适的位置**插入：已有相关 section → 合并进去；新类别 → 在相邻 section 附近创建
3. **禁止追加到文件末尾**——保持文档组织性

**工具**: `Edit`

### Layer 2：项目根配置

**写入目标**: 探测到的项目根配置文件

**插入策略**: 同 Layer 1。

**工具**: `Edit`

### Layer 3：子模块配置

**写入目标**: 与学习内容语义最近的子模块配置文件

**插入策略**: 同 Layer 1。注意不要将子模块特定的知识写入根配置（避免上层膨胀），也不要将跨模块的通用知识写入子模块配置（避免重复）。

**工具**: `Edit`

### Layer 4：情境记忆

**写入目标**: 探测到的记忆后端

**策略因后端而异**:
- **工具后端**: 使用其提供的 API 创建/更新条目。
- **文件系统后端**: 使用 Read/Edit/Write 操作 markdown 文件。文件按主题分类（如 `problem-solving.md`、`patterns.md`），保持简洁，用 bullet points。

## 用户确认流程

**重要**: 持久化前必须展示分类结果并获得用户确认。

### 第一步：展示分类

```markdown
## 会话学习摘要

### L1 用户配置（写入 {探测到的文件名}）
- [偏好 1]

### L2 项目根配置（写入 {探测到的文件名}）
- [项 1]

### L3 子模块配置（写入 {探测到的文件名}）
- [子模块知识 1]

### L4 情境记忆（写入 {探测到的后端描述}）
- [经验 1]
```

### 第一步.5：跨层去重（MANDATORY）

- 对每条学习项，在所有已探测到的存储位置检索关键词，确认是否已存在同义内容。
- 若发现重复或冲突，向用户展示并用 AskUserQuestion 提供处理选项。
- 默认不自动覆盖。

### 第二步：使用 AskUserQuestion 确认

- **multiSelect**: true
- 每个学习项作为一个选项（label 含层级，description 含内容摘要）

用户可选择全部、部分或跳过。

### 第三步：执行持久化

确认后：
1. 写入用户配置文件（如有）
2. 写入项目根配置文件（如有）
3. 写入子模块配置文件（如有）
4. 写入情境记忆后端（如有）
5. 报告保存了什么、保存到哪里

### 第四步：记忆整理（仅当使用工具后端时）

仅在使用了支持图谱/实体的记忆工具时执行。文件系统后端不需要。

1. 查看当前数据，识别重复/冲突/孤立内容
2. 合并重复、连接孤立项（不可丢失有价值信息）
3. 向用户报告整理了什么

如果数据已经干净，明确说明"已检查，无需整理"。

## 错误处理

- 配置文件不存在 → 创建并添加适当头部
- 子模块无配置文件 → 归入 Layer 2
- 情境记忆后端不可用 → 降级到下一优先级后端
- 所有后端都不可用 → 使用兜底方案
- 用户拒绝所有项目 → 确认并不持久化

---

## 历史分析模式

**仅当模式路由判定为"历史模式"时执行此 section。**

从 agent 历史会话日志中批量提取交互模式，发现 CLAUDE.md / AGENTS.md 的改进点。

### Phase 1: 发现（环境自适应）

**核心原则**：不硬编码任何路径。利用 agent 的自认知能力自适应定位资源。

#### Step 1.1: 识别身份

你已通过 system prompt 知道自己是哪个 agent 工具。确认：

- **工具名称**：Claude Code / OpenCode / Codex / 其他
- **数据目录命名惯例**：通常为 `~/.<tool-name>/` 或 `~/.local/share/<tool-name>/`

#### Step 1.2: 定位配置文件

从 cwd 开始向上搜索，收集所有项目级配置文件：

```
CLAUDE.md
AGENTS.md
.claude/CLAUDE.md
.claude/AGENTS.md
```

记录每个文件的路径和内容摘要——这些是改进的目标文件。

#### Step 1.3: 定位会话历史

**搜索策略**（按优先级尝试）：

1. **已知的 agent 数据目录**：检查 home 目录下与当前 agent 工具关联的目录
   - `~/.<agent-name>/` 目录结构
   - `~/.local/share/<agent-name>/`（XDG 规范）
2. **搜索会话文件**：在候选目录中搜索常见存储格式
   - `*.jsonl`（JSON Lines，Claude Code 常用）
   - `*.db` / `*.sqlite`（SQLite，OpenCode 常用）
   - `*.json`（普通 JSON）
3. **项目关联筛选**：筛选与当前项目路径相关的会话
   - 检查文件路径/目录名是否包含当前项目名
   - 检查会话内容中是否引用了当前项目路径

**输出**：向用户报告发现结果（找到的配置文件和相关会话数量），确认后进入 Phase 2。

### Phase 2: 分析（模式检测）

从会话历史中提取有意义的交互模式，揭示配置中缺失、过时或需调整的规则。

#### 读取约束

- 最多读取最近 **20 个**会话（避免过量 token 消耗）
- 优先读取 **user 类型消息**（用户消息包含偏好信号，agent 回复通常是执行结果）
- 有 summary/title 字段时，先用摘要快速筛选，跳过明显无关的会话

#### 模式检测

扫描会话内容，检测以下信号：

| 信号类型 | 检测方法 | 映射到的建议类型 |
|----------|----------|------------------|
| **明确纠正** | 搜索用户消息中的纠正短语——中文："不要"/"别"/"不是…是…"/"我说的是"/"我要的是"/"请用"；英文："don't"/"stop"/"I said"/"I meant"/"please use"。确认后续 agent 消息含调整信号（"好的"/"抱歉"/"明白"等）。**单次即有效。** | 新增规则（配置中无相关规则时）或 修改规则（已有但不够明确时） |
| **重复纠正** | 对"明确纠正"检测到的结果按主题聚类。**同一主题跨 ≥2 个会话被纠正**，信号升级。 | 新增规则（高优先级——反复纠正说明配置明确缺失） |
| **隐含偏好** | 检测用户在 **≥3 个会话**中对同类选择做出相同决定（如总是选择某工具、某命名风格、某工作流模式），但配置中无对应规则。关注：工具选择、文件命名、代码风格、沟通语言、响应长度等维度。 | 新增规则 |
| **偏好冲突** | 先提取现有配置中的规则列表。对每个检测到的"明确纠正"，检查是否有对应的配置规则——**有规则但仍被纠正**，说明规则表述不清或已过时。 | 修改规则 |
| **过时规则** | 提取配置文件中所有具体行为规则（排除身份性/通用性规则如语言设置）。在最近会话中搜索每条规则的关键词。**最近 10+ 个会话中从未触发且不属于低频场景的规则**，标记为可能过时。 | 可能过时的规则 |
| **负面情绪** | 搜索情绪信号词：连续感叹号(≥2)、全大写词(≥3字母)、"又"/"again"/"还是"/"为什么总是"/"怎么又"。**仅标记相关会话片段供人工审查**，不直接生成建议——情绪信号需人工判断根因。 | 待确认 |

#### 分析输出

对每个检测到的模式，记录：
- **信号类型**：属于哪种模式
- **证据**：来自哪个会话、具体的用户消息片段
- **出现频次**：跨会话出现了几次（频次越高，信号越强）
- **对应的现有配置规则**（如有）：是否已有相关规则但未被遵循

### Phase 3: 建议（结构化输出）

#### 3.1 生成建议

将 Phase 2 的分析结果组织为四类：

```markdown
## 改进建议

### 新增规则
1. [建议的规则内容]
   — 来源：会话 X、Y 中用户 N 次表达了...
   — 目标文件：[CLAUDE.md / AGENTS.md 路径]

### 修改规则
1. [现有规则] → [建议修改为]
   — 来源：会话 X 中用户纠正了...
   — 目标文件：[路径]

### 可能过时的规则
1. [规则内容]
   — 原因：最近 N 个会话中从未触发 / 被反复覆盖
   — 目标文件：[路径]

### 待确认
1. [不确定的发现]
   — 需要用户判断：[具体问题]
```

#### 3.2 用户确认

使用 **AskUserQuestion** 让用户逐条审核：

- **multiSelect**: true
- 每个建议作为一个选项（label 含类型标签，description 含完整建议和来源）
- 用户可选择全部、部分或跳过

#### 3.3 执行修改

仅对用户确认的建议执行：

1. **阅读目标文件**完整内容，理解现有结构
2. **找到语义合适的位置**插入/修改：
   - 已有相关 section → 合并进去
   - 新类别 → 在相邻 section 附近创建
   - **禁止追加到文件末尾**——保持文档组织性
3. 对于"过时规则"类建议，**不自动删除**——仅添加注释标记或询问用户是否删除
4. 使用 **Edit** 工具执行修改

#### 3.4 完成报告

报告执行结果：
- 修改了哪些文件
- 每个文件做了什么改动
- 跳过了哪些建议及原因

### 历史模式错误处理

| 场景 | 处理方式 |
|------|----------|
| 找不到配置文件 | 报告未发现，询问用户是否创建 |
| 找不到会话历史 | 报告搜索路径和结果，请用户指定位置 |
| 会话格式无法解析 | 读取少量样本记录推断结构；推断失败则跳过该文件，继续处理其他会话源，最终报告跳过清单及原因 |
| 会话数据过大 | 严格遵守 20 会话上限，优先最近的 |
| 无有意义的模式 | 如实报告"未发现明显的改进信号"，不生造建议 |
