---
name: auto-extract
description: 会话学习技能 - 分析当前会话，提取学习并持久化到四层存储（用户配置、项目配置、子模块配置、情境记忆）
---

# 会话学习技能

分析当前会话，提取有价值的学习内容，并持久化到合适的存储层。

## 分析维度

回顾会话，关注：

| 维度 | 关注点 |
|------|--------|
| **进展顺利** | 成功的方法、有效的解决方案、好的决策 |
| **进展不顺** | 失败的尝试、错误的方向、浪费时间的地方 |
| **用户分歧** | 用户纠正你的地方、拒绝的建议、表达不满的地方 |
| **推断偏好** | 沟通风格、工具偏好、代码风格、工作流习惯 |

## 四层分类

### 语义定义

| 层级 | 核心问题 | 特性 |
|------|----------|------|
| Layer 1: 用户配置 | "每个会话都需要知道什么？" | 跨项目、身份性、自动加载 |
| Layer 2: 项目根配置 | "这个项目整体需要知道什么？" | 项目级、版本控制 |
| Layer 3: 子模块配置 | "这个子模块需要知道什么？" | 子模块特定、就近原则 |
| Layer 4: 情境记忆 | "特定情境下需要召回什么？" | 情境性、按需查询 |

### 硬规则：单条知识唯一归属

- 每条学习项选择一个且仅一个存储层。
- 禁止跨层重复（包括改写后的同义重复）。
- 写入前，执行跨层去重检查：在所有已探测到的存储位置检索关键词。
- 发现重复或冲突时，使用 AskUserQuestion 让用户决定（移动 / 覆盖 / 忽略）；默认不自动覆盖。

### 决策树

```
对于每个学习项，依次问：
│
├─ Q1: 是否是每个新会话、跨所有项目都需要的信息？
│   ├─ 是 → Layer 1 用户配置
│   └─ 否 → 继续 Q2
│
├─ Q2: 是否与当前项目整体相关？
│   ├─ 是 → Layer 2 项目根配置
│   └─ 否 → 继续 Q3
│
├─ Q3: 是否与项目中某个特定子模块/子目录相关？
│   ├─ 是 → Layer 3 子模块配置（写入最近的子目录配置文件）
│   └─ 否 → 继续 Q4
│
└─ Q4: 是否是特定情境才需要的经验/知识/解决方案？
    └─ 是 → Layer 4 情境记忆
```

**关键区分**：
- **用户配置**: "What I always need to know"（身份/常驻规则）
- **项目根配置**: "What this project needs to know"（项目约定）
- **子模块配置**: "What this submodule needs to know"（子模块约定，就近放置）
- **情境记忆**: "What I learned for specific situations"（情境经验）

### 分类示例

| 学习内容 | 层级 | 理由 |
|----------|------|------|
| "用户偏好 bun 而非 npm" | L1 用户 | 跨项目的工具选择 |
| "用户偏好简洁响应" | L1 用户 | 跨项目的风格偏好 |
| "用户偏好中文交流" | L1 用户 | 跨项目的语言设置 |
| "这个项目有 19 个独立插件" | L2 项目根 | 项目整体结构 |
| "插件 plugin.json 不要用 $schema 字段" | L2 项目根 | 项目通用规范 |
| "oc-tweaks 发布必须走 CI，禁止 npm publish" | L3 子模块 | oc-tweaks 子模块特定 |
| "openspec proposal 必须包含 Why 和 What Changes" | L3 子模块 | openspec 子模块特定 |
| "GitHub Code Search 按相关性排序" | L4 情境记忆 | 特定技术的经验教训 |
| "并行 API 调用用 ThreadPoolExecutor" | L4 情境记忆 | 特定场景的解决方案 |

## 存储层探测协议

在持久化前，先探测当前环境可用的存储后端。**不假设任何特定插件或 MCP 存在。**

### 第零步：探测可用后端

#### Layer 1 — 用户配置

扫描用户级配置文件，检测是否存在：
- `~/.claude/CLAUDE.md`
- 其他用户级 agent 配置文件

检测到的文件均参与去重检查。不存在则创建 `~/.claude/CLAUDE.md` 并添加适当头部。

#### Layer 2 — 项目根配置

扫描项目根目录，检测以下文件是否存在：
- `{repo}/AGENTS.md`
- `{repo}/CLAUDE.md`
- `{repo}/.claude/CLAUDE.md`

所有检测到的文件均参与去重检查。写入时选择语义最合适的一个。

#### Layer 3 — 子模块配置

扫描项目中子目录里已存在的配置文件（AGENTS.md 或 CLAUDE.md）。这些文件代表该子模块有独立的知识边界。

**探测方式**: 搜索 `{repo}/**/AGENTS.md` 和 `{repo}/**/CLAUDE.md`（排除根目录，排除 node_modules 等）。

所有检测到的文件均参与去重检查。写入时选择与学习内容语义最近的子模块配置。如果没有发现任何子模块配置文件，则将 Q3 的内容归入 Layer 2。

#### Layer 4 — 情境记忆

按优先级探测可用的记忆后端：

1. **记忆相关的工具**: 检查当前环境是否有可调用的记忆存储工具（能创建、查询、更新知识条目的工具）。有则用。
2. **已存在的 memory 目录**: 检查项目级或全局是否存在 memory 目录（含 `*.md` 文件）。有则用 Read/Edit/Write 操作。
3. **兜底**: 以上都不可用 → 在项目内创建 `.memory/` 目录，以 markdown 文件存储。

**原则**: 探测到什么用什么。不要求用户安装任何额外依赖。

## 持久化指南

### Layer 1：用户配置

**写入目标**: 探测到的用户级配置文件

**插入策略**:
1. **先阅读整个文件**，理解现有结构
2. **找到语义合适的位置**插入：已有相关 section → 合并进去；新类别 → 在相邻 section 附近创建
3. **禁止追加到文件末尾**——保持文档组织性

**工具**: `Edit`

### Layer 2：项目根配置

**写入目标**: 探测到的项目根配置文件

**插入策略**: 同 Layer 1。

**工具**: `Edit`

### Layer 3：子模块配置

**写入目标**: 与学习内容语义最近的子模块配置文件

**插入策略**: 同 Layer 1。注意不要将子模块特定的知识写入根配置（避免上层膨胀），也不要将跨模块的通用知识写入子模块配置（避免重复）。

**工具**: `Edit`

### Layer 4：情境记忆

**写入目标**: 探测到的记忆后端

**策略因后端而异**:
- **工具后端**: 使用其提供的 API 创建/更新条目。
- **文件系统后端**: 使用 Read/Edit/Write 操作 markdown 文件。文件按主题分类（如 `problem-solving.md`、`patterns.md`），保持简洁，用 bullet points。

## 用户确认流程

**重要**: 持久化前必须展示分类结果并获得用户确认。

### 第一步：展示分类

```markdown
## 会话学习摘要

### L1 用户配置（写入 {探测到的文件名}）
- [偏好 1]

### L2 项目根配置（写入 {探测到的文件名}）
- [项 1]

### L3 子模块配置（写入 {探测到的文件名}）
- [子模块知识 1]

### L4 情境记忆（写入 {探测到的后端描述}）
- [经验 1]
```

### 第一步.5：跨层去重（MANDATORY）

- 对每条学习项，在所有已探测到的存储位置检索关键词，确认是否已存在同义内容。
- 若发现重复或冲突，向用户展示并用 AskUserQuestion 提供处理选项。
- 默认不自动覆盖。

### 第二步：使用 AskUserQuestion 确认

- **multiSelect**: true
- 每个学习项作为一个选项（label 含层级，description 含内容摘要）

用户可选择全部、部分或跳过。

### 第三步：执行持久化

确认后：
1. 写入用户配置文件（如有）
2. 写入项目根配置文件（如有）
3. 写入子模块配置文件（如有）
4. 写入情境记忆后端（如有）
5. 报告保存了什么、保存到哪里

### 第四步：记忆整理（仅当使用工具后端时）

仅在使用了支持图谱/实体的记忆工具时执行。文件系统后端不需要。

1. 查看当前数据，识别重复/冲突/孤立内容
2. 合并重复、连接孤立项（不可丢失有价值信息）
3. 向用户报告整理了什么

如果数据已经干净，明确说明"已检查，无需整理"。

## 错误处理

- 配置文件不存在 → 创建并添加适当头部
- 子模块无配置文件 → 归入 Layer 2
- 情境记忆后端不可用 → 降级到下一优先级后端
- 所有后端都不可用 → 使用兜底方案
- 用户拒绝所有项目 → 确认并不持久化
